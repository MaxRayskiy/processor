void push(num_t num) {
  sp -= sizeof(StackValueType);
  *(StackValueType*)sp = num;
}

void push(reg_t reg) {
  push(r[reg]);
}

void pop(reg_t reg) {
  r[reg] = *(StackValueType*)sp;
  sp += sizeof(StackValueType);
}

void mov(reg_t reg, num_t num) {
  r[reg] = num;
}

void mov(reg_t reg1, reg_t reg2) {
  mov(reg1, r[reg2]);
}

void fmov(ftreg_t freg, ftnum_t num) {
  xmm[freg] = num;
}

void fmov(ftreg_t freg1, ftreg_t freg2) {
  fmov(freg1, xmm[freg2]);
}

void in() {
  StackValueType value = 0;
  scanf("%lu", &value);
  push((num_t)value);
}

void in(reg_t reg) {
  scanf("%ld", &r[reg]);
}

void fin(ftreg_t freg) {
  scanf("%lf", &xmm[freg]);
}

void out() {
  printf("%ld\n", *(StackValueType*)sp);
  sp += sizeof(StackValueType);
}

void out(reg_t reg) {
  printf("%ld\n", r[reg]);
}

void fout(ftreg_t freg) {
  printf("%.2f\n", xmm[freg]);
}

void cmp(num_t num1, num_t num2) {
  num1 -= num2;
  ZF = 0;
  SF = 0;
  CF = 0;
  OF = 0;
  if (num1 == 0) {
    ZF = 1;
  } else
  if (num1 < 0) {
    SF = 1;
  }
}

void cmp(reg_t reg, num_t num) {
  cmp(r[reg], num);
}

void cmp(reg_t reg1, reg_t reg2) {
  cmp(r[reg1], r[reg2]);
}

void fcmp(ftnum_t num1, ftnum_t num2) {
  num1 -= num2;
  ZF = 0;
  SF = 0;
  CF = 0;
  OF = 0;
  if (num1 == 0) {
    ZF = 1;
  } else
  if (num1 < 0) {
    SF = 1;
  }
}

void fcmp(ftreg_t freg, ftnum_t num) {
  fcmp(xmm[freg], num);
}

void fcmp(ftreg_t freg1, ftreg_t freg2) {
  fcmp(xmm[freg1], xmm[freg2]);
}

void add(reg_t reg, num_t num) {
  r[reg] += num;
}

void add(reg_t reg1, reg_t reg2) {
  add(reg1, r[reg2]);
}

void fadd(ftreg_t freg, ftnum_t num) {
  xmm[freg] += num;
}

void fadd(ftreg_t freg1, ftreg_t freg2) {
  fadd(freg1, xmm[freg2]);
}

void sub(reg_t reg, num_t num) {
  r[reg] -= num;
}

void sub(reg_t reg1, reg_t reg2) {
  sub(reg1, r[reg2]);
}

void fsub(ftreg_t freg, ftnum_t num) {
  xmm[freg] -= num;
}

void fsub(ftreg_t freg1, ftreg_t freg2) {
  fsub(freg1, xmm[freg2]);
}

void mul(reg_t reg, num_t num) {
  r[reg] *= num;
}

void mul(reg_t reg1, reg_t reg2) {
  mul(reg1, r[reg2]);
}

void fmul(ftreg_t freg, ftnum_t num) {
  xmm[freg] *= num;
}

void fmul(ftreg_t freg1, ftreg_t freg2) {
  fmul(freg1, xmm[freg2]);
}

void fdiv(ftreg_t freg, ftnum_t num) {
  xmm[freg] /= num;
}

void fdiv(ftreg_t freg1, ftreg_t freg2) {
  fdiv(freg1, xmm[freg2]);
}

void fsqrt(ftreg_t freg) {
  xmm[freg] = sqrt(xmm[freg]);
}

void lnot(reg_t reg) {
  r[reg] = ~r[reg];
}

void flnot(ftreg_t freg) {
  uint64_t tmp = ~reinterpret_cast<uint64_t&>(xmm[freg]);
  xmm[freg] = reinterpret_cast<double&>(tmp);
}

void finf(ftreg_t freg) {
  xmm[freg] = std::numeric_limits<double>::infinity();
}

void jmp(label_type pos) {
  pc = text + pos + sizeof(Command);
}

void jz(label_type pos) {
  if (ZF == 1) {
    jmp(pos);
  }
}

void jnz(label_type pos) {
  if (ZF == 0) {
    jmp(pos);
  }
}

void jl(label_type pos) {
  if (SF == 1) {
    jmp(pos);
  }
}

void jg(label_type pos) {
  if (SF == 0) {
    jmp(pos);
  }
}

void jle(label_type pos) {
  if (ZF == 1 || SF == 1) {
    jmp(pos);
  }
}

void jge(label_type pos) {
  if (ZF == 1 || SF == 0) {
    jmp(pos);
  }
}

void call(label_type pos) {
  push((num_t)pc);
  jmp(pos);
}

void ret() {
  pop(13);
  pc = (char*)r[13];
}

void end() {
  pc = ram;
}

